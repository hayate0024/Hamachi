<!DOCTYPE html>
<html lang="ja">
<head>
    <meta property="og:description" content="ハマチとカンパチを仕分けるゲームです。">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ハマチ カンパチ シワケ</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=DotGothic16&display=swap" rel="stylesheet">
    <style>
        :root {
            --font-retro: 'DotGothic16', 'Press Start 2P', cursive, monospace;

            --color-bg-outer: #000;
            --color-bg-game: #0000ff;
            --color-bg-overlay: rgba(0, 0, 0, 0.95);
            --color-bg-explanation: #003300;
            --color-bg-ranking: rgba(0,0,0,0.7);
            --color-bg-input: rgba(0, 0, 0, 0.7);

            --color-text-main: #009900;
            --color-text-shadow-main: #006600;
            --color-text-light: #ccffcc;
            --color-text-title: #ffcc00;
            --color-text-title-shadow: #cc9900;
            --color-text-title-shadow-deep: #996600;
            --color-text-lives: #ff3399;
            --color-text-lives-shadow: #cc0066;
            --color-text-gameover: #ff6699;
            --color-text-gameover-shadow: #990033;
            --color-text-placeholder: #006600;
            --color-text-white: #fff;

            --color-border-main: #006600;
            --color-border-title: #cc9900;
            --color-border-gameover: #ff6699;
            --color-border-hamachi: #3399ff;
            --color-border-kanpachi: #ff3399;
            --color-border-exit: #660000;

            --shadow-box-main: 4px 4px 0px 0px rgba(0, 102, 0, 0.7);
            --shadow-box-title: 4px 4px 0px 0px rgba(204, 153, 0, 0.7);
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--color-bg-outer);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: var(--font-retro);
            color: var(--color-text-main);
            font-weight: bold;
            text-shadow: 2px 2px var(--color-text-shadow-main);
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
        }

        #gameContainer, #startButtonContainer {
            position: relative;
            border: 2px solid var(--color-border-main);
            background: var(--color-bg-game);
            box-sizing: border-box;
            box-shadow: var(--shadow-box-main);
        }

        canvas {
            display: block;
            background: var(--color-bg-game);
            width: 100%;
            height: 100%;
        }

        #ui {
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: space-around;
            padding: 5px 0;
            box-sizing: border-box;
            font-size: clamp(12px, 2vw, 16px);
            margin-bottom: 10px;
        }

        #ui #lives {
            color: var(--color-text-lives);
            text-shadow: 2px 2px var(--color-text-lives-shadow);
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--color-text-gameover);
            font-size: clamp(18px, 4vw, 24px);
            z-index: 100;
            display: none;
            background-color: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid var(--color-border-gameover);
            text-shadow: 2px 2px var(--color-text-gameover-shadow);
            box-shadow: 0 0 20px rgba(255, 102, 153, 0.5);
        }

        #gameOver div {
            margin-bottom: 5px;
        }

        #gameOver button {
            background-color: var(--color-text-gameover);
            color: var(--color-text-white);
            border: 2px solid var(--color-text-lives-shadow);
            padding: 10px 20px;
            font-size: clamp(14px, 3vw, 18px);
            cursor: pointer;
            border-radius: 5px;
            margin-top: 15px;
            font-family: var(--font-retro);
            text-shadow: 2px 2px var(--color-text-gameover-shadow);
        }

        #gameOver button:hover {
            background-color: var(--color-text-lives-shadow);
        }

        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            justify-content: center;
            align-items: flex-end;
            z-index: 30;
            pointer-events: none;
            gap: 10px;
            box-sizing: border-box;
            width: calc(100% - 20px);
            max-width: 780px;
            padding-bottom: 10px;
        }

        .control-button {
            background-color: rgba(0, 153, 0, 0.2);
            border: 2px solid var(--color-border-main);
            color: var(--color-text-main);
            font-size: clamp(16px, 4vw, 24px);
            padding: 10px 5px;
            border-radius: 10px;
            cursor: pointer;
            flex-shrink: 0;
            font-family: var(--font-retro);
            pointer-events: auto;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            height: clamp(50px, 12vw, 80px);
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #leftButton, #rightButton {
            width: 60px;
        }

        .control-button.shoot {
            font-size: clamp(14px, 3.2vw, 18px);
            width: calc(50% - 70px);
            flex-grow: 0;
        }

        .control-button.shoot-hamachi {
            background-color: rgba(51, 153, 255, 0.2);
            border: 2px solid var(--color-border-hamachi);
            color: #66ccff;
            text-shadow: 2px 2px #0066cc;
        }

        .control-button.shoot-kanpachi {
            background-color: rgba(255, 51, 153, 0.2);
            border: 2px solid var(--color-border-kanpachi);
            color: #ff66cc;
            text-shadow: 2px 2px var(--color-text-lives-shadow);
        }

        /* --- スタート画面のレイアウト調整 --- */
        #startButtonContainer {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            padding: 20px;
            text-align: center;
            height: 100%;
        }

        #startButtonContainer h1 {
            color: var(--color-text-title);
            font-size: clamp(32px, 8vw, 70px);
            margin: 0 0 25px 0;
            text-shadow: 3px 3px var(--color-text-title-shadow);
            animation: retro-blink 1.6s steps(1, end) infinite;
        }

        @keyframes retro-blink {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        #startButton, #explainButton, #rankingButton {
            border-radius: 10px;
            cursor: pointer;
            font-family: var(--font-retro);
            box-shadow: var(--shadow-box-main);
            box-sizing: border-box;
            text-align: center;
            width: clamp(200px, 60vw, 320px);
            margin-bottom: 15px;
        }

        #startButton {
            background-color: var(--color-text-title);
            color: var(--color-text-white);
            border: 2px solid var(--color-border-title);
            text-shadow: 3px 3px var(--color-text-title-shadow-deep);
            box-shadow: var(--shadow-box-title);
            padding: 12px 25px;
            font-size: clamp(16px, 3.5vw, 28px);
            order: 1;
        }
        #startButton:hover {
            background-color: var(--color-text-title-shadow);
        }

        #explainButton, #rankingButton {
            background-color: var(--color-text-main);
            color: var(--color-text-white);
            border: 2px solid var(--color-border-main);
            text-shadow: 2px 2px var(--color-text-shadow-main);
            height: clamp(40px, 8vw, 55px);
            padding: 8px 15px;
            font-size: clamp(14px, 3vw, 22px);
        }
        #explainButton:hover, #rankingButton:hover {
            background-color: var(--color-text-shadow-main);
        }

        #explainButton { order: 2; }
        #rankingButton { order: 3; }

        #playerNameSection {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        #playerNameInput {
            background-color: var(--color-bg-input);
            border: 2px solid var(--color-text-main);
            color: var(--color-text-title);
            font-family: var(--font-retro);
            font-size: clamp(14px, 2.5vw, 20px);
            padding: 10px 15px;
            margin-bottom: 5px;
            text-align: center;
            width: clamp(200px, 60vw, 320px);
            box-sizing: border-box;
            border-radius: 5px;
            text-shadow: 1px 1px var(--color-text-shadow-main);
        }

        #playerNameInput::placeholder {
            color: var(--color-text-placeholder);
            opacity: 0.8;
            text-shadow: 1px 1px #003300;
        }

        #playerNameErrorMessage {
            color: var(--color-text-title);
            text-shadow: 1px 1px var(--color-text-title-shadow);
            font-size: clamp(12px, 2vw, 16px);
            margin-bottom: 10px;
            min-height: 20px;
            visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
            box-sizing: border-box;
        }

        #personalHighScore {
            order: 4;
            margin-top: 30px;
            font-size: clamp(16px, 3.5vw, 24px);
            color: var(--color-text-light);
            text-shadow: 2px 2px var(--color-text-shadow-main);
        }
        /* --- スタート画面の調整ここまで --- */

        #explanationOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--color-bg-overlay);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: var(--color-text-white);
            padding: 20px;
            box-sizing: border-box;
            text-shadow: 1px 1px #000;
        }

        #explanationContent {
            background-color: var(--color-bg-explanation);
            border: 2px solid var(--color-text-main);
            border-radius: 8px;
            padding: 25px;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            text-align: left;
            box-shadow: 0 0 30px rgba(0, 153, 0, 0.5);
            color: var(--color-text-light);
            font-size: clamp(14px, 2.2vw, 18px);
        }

        #explanationContent h2 {
            color: var(--color-text-title);
            text-align: center;
            margin-top: 0;
            margin-bottom: 20px;
            text-shadow: 2px 2px var(--color-text-title-shadow);
            white-space: nowrap;
            max-width: 100%;
            flex-shrink: 0;
            width: auto;
            line-height: 1.2;
            margin-left: auto;
        }

        #explanationContent h3 {
            color: #aaffee;
            margin-top: 15px;
            margin-bottom: 8px;
            font-size: clamp(16px, 2.8vw, 22px);
            text-shadow: 1px 1px #6688aa;
        }

        #explanationContent p {
            margin-bottom: 10px;
            line-height: 1.5;
        }

        #explanationContent ul {
            padding-left: 20px;
            margin-bottom: 15px;
        }

        #explanationContent li {
            margin-bottom: 5px;
        }

        .close-button {
            display: block;
            width: fit-content;
            margin: 20px auto 0;
            padding: 10px 25px;
            background-color: var(--color-text-main);
            color: var(--color-text-white);
            border: 2px solid var(--color-border-main);
            border-radius: 5px;
            cursor: pointer;
            font-family: var(--font-retro);
            font-size: clamp(14px, 2.5vw, 20px);
            text-shadow: 1px 1px var(--color-text-shadow-main);
        }
        .close-button:hover {
            background-color: var(--color-text-shadow-main);
        }

        .enemy-block {
            background-color: #006600;
            border: 2px solid #003300;
            color: #99ff99;
            text-shadow: 2px 2px #003300;
            box-shadow: 2px 2px 0px 0px rgba(0, 51, 0, 0.7);
        }

        #exitButton {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 8px 15px;
            background-color: #990000;
            color: var(--color-text-white);
            border: 2px solid var(--color-border-exit);
            border-radius: 5px;
            cursor: pointer;
            font-family: var(--font-retro);
            font-size: clamp(12px, 2vw, 16px);
            text-shadow: 1px 1px #330000;
            z-index: 1000;
            display: none;
        }
        #exitButton:hover {
            background-color: var(--color-border-exit);
        }

        #spreadsheetOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }

        #spreadsheetOverlay .overlay-content {
            background-color: var(--color-bg-explanation);
            border: 2px solid var(--color-text-main);
            border-radius: 8px;
            padding: 25px;
            position: relative;
            width: auto;
            text-align: center;
            max-width: 90vw;
            max-height: 90vh;
            overflow: hidden;
            color: var(--color-text-main);
        }

        #spreadsheetOverlay .iframe-wrapper {
            position: relative;
            width: 295px;
            height: 205px;
            border: 2px solid #111;
            border-radius: 8px;
            background-color: #000;
            overflow: hidden;
            z-index: 1;
        }

        #spreadsheetOverlay .iframe-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background-image: repeating-linear-gradient(
                to bottom,
                rgba(0, 255, 0, 0.15),
                rgba(0, 255, 0, 0.15) 1px,
                transparent 1px,
                transparent 4px
            );
            animation: scanline-scroll 2s infinite linear;
        }


        #spreadsheetOverlay iframe {
            width: 295px;
            height: 205px;
            border: none;
            display: block;
            margin: 0 auto;
            overflow: auto;
        }

        #spreadsheetOverlay .overlay-content::before {
            content: '';
            position: absolute;
            top: 21px;
            left: 21px;
            width: 303px;
            height: 213px;
            border-radius: 8px;
            box-shadow: inset 0 0 0 15px #000080, 2px 2px 8px rgba(0,0,0,0.7);
            pointer-events: none;
            z-index: 2;
        }

        #spreadsheetOverlay .close-button {
            margin-top: 20px;
        }

        @keyframes scanline-scroll {
            from {
                background-position-y: 0;
            }
            to {
                background-position-y: 4px;
            }
        }
    </style>
</head>
<body>
    <div id="ui" style="display: none;">
        <div>スコア: <span id="score">0</span></div>
        <div>ライフ: <span id="lives">3</span></div>
        <div>レベル: <span id="level">1</span></div>
    </div>
    <div id="gameContainer" style="display: none;">
        <canvas id="gameCanvas" width="800" height="800"></canvas>
        <div id="gameOver">
            <div>ゲームオーバー</div>
            <div>最終スコア: <span id="finalScore">0</span></div>
            <div id="yourRank"></div>
            <button id="restartButton">もどる</button>
        </div>
        
        <div id="mobileControls" style="display: none;">
            <button id="leftButton" class="control-button">←</button>
            <button id="shootHamachiButton" class="control-button shoot shoot-hamachi">ハマチ！</button>
            <button id="shootKanpachiButton" class="control-button shoot shoot-kanpachi">カンパチ！</button>
            <button id="rightButton" class="control-button">→</button>
        </div>
    </div>
    <button id="exitButton" style="display: none;">EXIT</button>

    <div id="startButtonContainer">
      <h1 id="mainTitle">ハマチ カンパチ シワケ</h1>

      <div id="playerNameSection">
          <input type="text" id="playerNameInput" placeholder="名前を入力">
          <div id="playerNameErrorMessage"></div>
      </div>

      <button id="startButton">
          ゲームスタート
      </button>

      <button id="explainButton">
          ゲーム説明
      </button>

      <button id="rankingButton">
          ランキング
      </button>

      <div id="personalHighScore">あなたの最高得点: まだありません</div>

    </div>

    <div id="explanationOverlay">
        <div id="explanationContent">
            <h2 id="explanationTitle">ゲーム説明</h2>
            <p>
                「ハマチ」と「カンパチ」、そしてその仲間たち。<br>
                これは「ハマチ」と「カンパチ」の理解を深めるためのゲームです。ザ・グレイトピープルズのハマチカンパチを感じる上での助けとなったりしなかったりするでしょう。
            </p>
            <h3>基本的なルール</h3>
            <ul>
                <li>プレイヤーは左右に移動できます。</li>
                <li>魚が上から降ってきます。魚はなぜか攻撃してきます。</li>
                <li>魚の名前を見て「ハマチ」の仲間なのか「カンパチ」の仲間なのかを判断し、適切な種類のショットで仕分けていきましょう。</li>
                <li>「ハマチ！」ボタンで「ハマチショット」（青い弾）を発射。</li>
                <li>「カンパチ！」ボタンで「カンパチショット」（ピンクの弾）を発射。</li>
                <li>正しい弾があたると魚は消えます（元の世界に帰ります）。</li>
                <li>誤った弾で魚を撃つと、魚が怒ってさらに降下してきます。</li>
                <li>正解すると10点加点、間違うと5点減点されます。</li>
                <li>魚の攻撃を受けるとライフが減ります。ライフがなくなったり魚がプレイヤーまで到達するとゲームオーバーです。</li>
                <li>すべての魚を仕分けるとレベルアップ！さらに多くの出世魚たちが現れます。</li>
            </ul>

            <h3>出世魚（しゅっせうお）について</h3>
            <p>
                「出世魚」とは、成長するにつれて呼び名が変わる魚のことです。地方によっても様々な呼び名があり、その多様性が日本の豊かな食文化を支えています。覚えましょう。
            </p>
            <h4>ブリ系（ハマチ系）の主な呼び名</h4>
             <p>ブリは、稚魚から成魚になるまでに何度も名前を変える、まさに「出世魚」の代表格です。</p>
            <ul>
                <li>一般的な呼び名
                    <ul>
                        <li>ワカシ/ツバス/ショゴなど: 35cm以下の幼魚。小さい段階。</li>
                        <li>イナダ/ハマチ/フクラギなど: 35～60cm程度の若魚。</li>
                        <li>ワラサ/メジロ/ガンドなど: 60～80cm程度の中型魚。</li>
                        <li>ブリ: 80cm以上の成魚。</li>
                    </ul>
                </li>
                <li>地域ごとの呼び名
                    <ul>
                        <li>関東地方:
                            <ul>
                                <li>ワカシ (35cm以下)</li>
                                <li>イナダ (35～60cm)</li>
                                <li>ワラサ (60～80cm)</li>
                                <li>ブリ (80cm以上)</li>
                            </ul>
                        </li>
                        <li>関西地方:
                            <ul>
                                <li>ツバス (35cm以下)</li>
                                <li>ハマチ (35～60cm)</li>
                                <li>メジロ (60～80cm)</li>
                                <li>ブリ (80cm以上)</li>
                            </ul>
                        </li>
                        <li>北陸地方:
                            <ul>
                                <li>コゾクラ (35cm以下)</li>
                                <li>フクラギ (35～60cm)</li>
                                <li>ガンド (60～80cm)</li>
                                <li>ブリ (80cm以上)</li>
                            </ul>
                        </li>
                        <li>九州地方:
                            <ul>
                                <li>ヤズ (35cm以下)</li>
                                <li>ワカナ (35～60cm)</li>
                                <li>ハマチ (60～80cm)</li>
                                <li>ブリ (80cm以上)</li>
                            </ul>
                        </li>
                        <li>その他の地域・呼び名:
                            <ul>
                                <li>東海地方: アブコ（幼魚）</li>
                                <li>東北地方: ショゴ（幼魚）、オオイナダ（大型）</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
            <h4>カンパチ系の主な呼び名</h4>
            <p>カンパチもまた、地方ごとに異なるユニークな呼び名を持つ出世魚です。
                <li>一般的な呼び名
                    <ul>
                        <li>ショッコ/シオッコ: 10～20cm程度の幼魚。非常に小さい段階。</li>
                        <li>シオ: 20～30cm程度の若魚。</li>
                        <li>アカバナ/アカバネ: 30～40cm程度の魚。体色が少し赤みを帯びることに由来。
                        <li>カンパチ: 50cm以上の成魚。</li>
                    </ul>
                </li>
                <li>地域ごとの呼び名
                    <ul>
                        <li>関東地方:
                            <ul>
                                <li>ショッコ/シオッコ (35cm以下)</li>
                                <li>シオゴ (60cmまで)</li>
                                <li>アカハナ (80cmまで)</li>
                                <li>カンパチ (80cm以上)</li>
                            </ul>
                        </li>
                        <li>関西地方:
                            <ul>
                                <li>シオ (60cmまで)</li>
                                <li>カンパチ (60cm以上)</li>
                            </ul>
                        </li>
                        <li>九州地方:
                            <ul>
                                <li>カンコ/ショッコ (幼魚)</li>
                                <li>アカバナ (若魚の一部)</li>
                                <li>カンパチ (成魚)</li>
                                <li>宮崎では「ニリ」、鹿児島では「ニノコ」、鹿児島県では「ネイゴ」や「アカバラ」という呼び名もあります。</li>
                                <li>幼魚を「ヒラゴ」、成魚を「ヒラス」と呼ぶこともあります。</li>
                            </ul>
                        </li>
                        <li>沖縄地方:
                            <ul>
                                <li>シオマー (幼魚)</li>
                                <li>カンパチ (成魚)</li>
                            </ul>
                        </li>
                        <li>その他の地域・呼び名:
                            <ul>
                                <li>アカイオ: 新潟県など北陸地方での呼び名。</li>
                                <li>ヒヨ: 神奈川県での呼び名。</li>
                                <li>チギリキ: 和歌山県や高知県での呼び名。</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
            <p>この知識が他で活きることもきっとあるはず。それでは頑張りましょう。</p>
            <button class="close-button" id="closeExplanationButton">閉じる</button>
        </div>
    </div>

    <div id="spreadsheetOverlay" class="overlay">
        <div class="overlay-content">
            <div class="iframe-wrapper">
                <iframe id="rankingIframe" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vRa0Q9xStdlDqAY18a_bpeyoGskywpikXjWiLNS9LKW_Km9Mg2uATO-vpVZhA_62JUde483QB4FSNUg/pubhtml?gid=493938141&amp;single=true&amp;widget=false&amp;headers=false&amp;gridlines=false&amp;range=A1:E6&amp;chrome=false"></iframe>
            </div>
            <button id="closeSpreadsheetButton" class="close-button">閉じる</button>
        </div>
    </div>

    <audio id="audio-hamachi" src="hamachi.mp3" preload="auto"></audio>
    <audio id="audio-kanpachi" src="kanpachi.mp3" preload="auto"></audio>
    <audio id="audio-chigau" src="chigau.mp3" preload="auto"></audio>
    <audio id="audio-vu" src="vu.mp3" preload="auto"></audio>
    <audio id="audio-start" src="start.mp3" preload="auto"></audio>
    <audio id="audio-clear" src="clear.mp3" preload="auto"></audio>
    <audio id="audio-retry"src="retry.mp3" preload="auto"></audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');

        const startButtonContainer = document.getElementById('startButtonContainer');
        const startButton = document.getElementById('startButton');
        const explainButton = document.getElementById('explainButton');
        const rankingButton = document.getElementById('rankingButton');
        const restartButton = document.getElementById('restartButton');
        const explanationOverlay = document.getElementById('explanationOverlay');
        const closeExplanationButton = document.getElementById('closeExplanationButton');
        const personalHighScoreDisplay = document.getElementById('personalHighScore');
        const playerNameInput = document.getElementById('playerNameInput');
        const playerNameErrorMessage = document.getElementById('playerNameErrorMessage');
        const yourRankDisplay = document.getElementById('yourRank');
        const exitButton = document.getElementById('exitButton');
        const spreadsheetOverlay = document.getElementById('spreadsheetOverlay');
        const closeSpreadsheetButton = document.getElementById('closeSpreadsheetButton');
        const mainTitle = document.getElementById('mainTitle');
        const explanationTitle = document.getElementById('explanationTitle');
        const rankingIframe = document.getElementById('rankingIframe');

        const GOOGLE_FORM_URL = 'https://docs.google.com/forms/u/0/d/e/1FAIpQLSc_Nch5Rt2IvGJb3h6-V4JeTkeJ76Xy0OhcES7zB2-0fwwdtg/formResponse';
        const FORM_PLAYER_NAME_ENTRY_ID = 'entry.1723250269';
        const FORM_SCORE_ENTRY_ID = 'entry.2114519163';
        const BASE_RANKING_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRa0Q9xStdlDqAY18a_bpeyoGskywpikXjWiLNS9LKW_Km9Mg2uATO-vpVZhA_62JUde483QB4FSNUg/pubhtml?gid=493938141&single=true&widget=false&headers=false&gridlines=false&range=A1:E6&chrome=false';


        const ORIGINAL_CANVAS_WIDTH = 800;
        const ORIGINAL_CANVAS_HEIGHT = 800;

        // ===== 魚の名称のタイポを修正 =====
        const HAMACHI_WORDS = [
            'ワカシ', 'ツバス', 'コゾクラ', 'ヤズ', 'アブコ', 'ショゴ',
            'イナダ', 'ハマチ', 'フクラギ', 'ガンド', 'ワカナ', 'ワラサ', 'メジロ',
            'オオイナダ', 'ブリ'
        ];
        const KANPACHI_WORDS = [
            'ショッコ', 'シオッコ', 'シオ', 'アカバナ', 'アカバネ', 'アカハナ', 'カンパチ', 'シオゴ',
            'カンコ', 'ニリ', 'ニノコ', 'ネイゴ', 'アカバラ', 'ヒラゴ', 'ヒラス',
            'シオマー', 'ヒヨ', 'チギリキ', 'アカイオ'
        ];
        const ALL_WORDS = [...HAMACHI_WORDS, ...KANPACHI_WORDS];

        const ENEMY_BASE_WIDTH = 120;
        const ENEMY_BASE_HEIGHT = 40;
        const ENEMY_COL_SPACING = 140;
        const ENEMY_ROW_SPACING = 60;
        const ENEMY_COLS = 5;
        const ENEMY_ROWS = 3;
        const ENEMY_START_Y_OFFSET = 110;

        const PLAYER_BASE_WIDTH = 40;
        const PLAYER_BASE_HEIGHT = 30;
        const PLAYER_Y_OFFSET_FROM_BOTTOM_BASE = 180;
        const BULLET_PLAYER_BASE_WIDTH = 4;
        const BULLET_PLAYER_BASE_HEIGHT = 10;
        const BULLET_PLAYER_BASE_SPEED = 7;
        const BULLET_ENEMY_BASE_WIDTH = 8;
        const BULLET_ENEMY_BASE_HEIGHT = 16;
        const BULLET_ENEMY_BASE_SPEED = 1.5;

        const SHOOT_COOLDOWN = 200;
        const PLAYER_GRID_MOVE_AMOUNT = 1;
        const ENEMY_DROP_AMOUNT_COLLISION = 20;
        const ENEMY_AUTO_DROP_FACTOR = 0.25;
        const ENEMY_SHOOT_CHANCE_BASE = 0.01;
        const ENEMY_SHOOT_CHANCE_LEVEL_FACTOR = 0.5;

        const BASE_AUTO_DROP_INTERVAL = 5000;
        const LEVEL_DROP_INTERVAL_REDUCTION = 250;
        const MIN_DROP_INTERVAL = 1200;

        const WATER_SURFACE_Y_OFFSET_FROM_ENEMY_TOP = -50;
        const WAVE_AMPLITUDE_BASE = 6;
        const WAVE_FREQUENCY_BASE = 0.2;
        const WATER_COLOR_TOP = '#66ccff';
        const WATER_COLOR_BOTTOM = '#0000aa';
        const WATER_LINE_COLOR = '#aaffee';
        const WATER_LINE_SHADOW_COLOR = '#6688aa';

        const PLAYER_COLOR = '#009900';
        const PLAYER_SHADOW_COLOR = '#006600';
        const PLAYER_BULLET_COLOR_HAMACHI = '#99ddff';
        const PLAYER_BULLET_COLOR_KANPACHI = '#ff99cc';
        const ENEMY_BULLET_COLOR = '#ff6666';
        const ENEMY_BULLET_SHADOW_COLOR = '#993333';

        let frameCount = 0;
        let UNIFIED_ENEMY_FONT_SIZE = 0;
        let showDebugLines = true;
        let audioContext;
        let animationFrameId;
        let enemyBlockStyles = {};

        let gameState = {
            player: {},
            bullets: [],
            enemies: [],
            enemyBullets: [],
            score: 0,
            lives: 3,
            level: 1,
            playerName: '',
            gameOver: false,
            isPaused: false,
            keys: {},
            lastShootTime: 0,
            lastEnemyAutoDropTime: 0,
            playerTargetPositions: [],
            currentPlayerTargetIndex: 0,
            personalHighScore: 0
        };

        function playSound(soundId) {
            const sound = document.getElementById(soundId);
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(e => {});
            }
        }

        function getScaleFactor() {
            return canvas.width > 0 ? canvas.width / ORIGINAL_CANVAS_WIDTH : 1;
        }

        function scale(value) {
            return value * getScaleFactor();
        }

        function resizeGameContainer() {
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const uiElement = document.getElementById('ui');
            const uiHeight = uiElement && uiElement.style.display !== 'none' ? uiElement.offsetHeight : 0;
            const offset = 20;
            const size = Math.min(vw - offset, vh - uiHeight - offset);

            gameContainer.style.width = `${size}px`;
            gameContainer.style.height = `${size}px`;
            startButtonContainer.style.width = `${size}px`;
            startButtonContainer.style.height = `${size}px`;

            canvas.width = size;
            canvas.height = size;
        }

        function adjustTextFontSizeSmart(element, maxFontSize, minFontSize = 5, paddingFactor = 0.98) {
            if (!element || !element.parentElement) return;
            const tempCanvas = document.createElement('canvas').getContext('2d');
            tempCanvas.imageSmoothingEnabled = false;
            const parentWidth = element.parentElement.clientWidth;
            const textContent = element.textContent;
            const computedStyle = getComputedStyle(element.parentElement);
            const availableWidth = parentWidth - (parseFloat(computedStyle.paddingLeft) || 0) - (parseFloat(computedStyle.paddingRight) || 0);

            let low = minFontSize, high = maxFontSize, optimalFontSize = minFontSize;

            while (low <= high) {
                let mid = Math.floor((low + high) / 2);
                tempCanvas.font = `${mid}px 'DotGothic16', 'Press Start 2P'`;
                const textWidth = tempCanvas.measureText(textContent).width;
                if (textWidth <= availableWidth * paddingFactor) {
                    optimalFontSize = mid;
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
            element.style.fontSize = `${optimalFontSize}px`;
        }

        function setupResizeObservers() {
            const createObserver = (element, max, min, factor) => {
                if (!element || !element.parentElement) return null;
                const observer = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        if (entry.target === element.parentElement) {
                            adjustTextFontSizeSmart(element, max, min, factor);
                        }
                    }
                });
                observer.observe(element.parentElement);
                return observer;
            };
            createObserver(mainTitle, 70, 10, 0.98);
            createObserver(explanationTitle, 32, 10, 0.98);
        }

        function cacheEnemyStyles() {
            const tempDiv = document.createElement('div');
            tempDiv.className = 'enemy-block';
            document.body.appendChild(tempDiv);
            const computedStyle = getComputedStyle(tempDiv);
            enemyBlockStyles = {
                mainColor: computedStyle.backgroundColor,
                shadowColor: computedStyle.boxShadow.split(')')[0] + ')',
                borderColor: computedStyle.borderColor,
                textColor: computedStyle.color,
                textShadow: computedStyle.textShadow
            };
            document.body.removeChild(tempDiv);
        }

        function init() {
            resizeGameContainer();
            ctx.imageSmoothingEnabled = false;

            gameState.player = {
                width: scale(PLAYER_BASE_WIDTH),
                height: scale(PLAYER_BASE_HEIGHT),
                y: canvas.height - scale(PLAYER_Y_OFFSET_FROM_BOTTOM_BASE),
                x: 0
            };

            calculateUnifiedEnemyFontSize();
            createEnemies();

            Object.assign(gameState, {
                bullets: [],
                enemyBullets: [],
                score: 0,
                lives: 3,
                level: 1,
                gameOver: false,
                isPaused: false,
                keys: {},
                lastShootTime: 0,
                lastEnemyAutoDropTime: performance.now()
            });
            frameCount = 0;

            if (gameState.playerTargetPositions.length > 0) {
                const middleIndex = Math.floor(gameState.playerTargetPositions.length / 2);
                gameState.currentPlayerTargetIndex = middleIndex;
                gameState.player.x = gameState.playerTargetPositions[middleIndex] - gameState.player.width / 2;
            }

            document.getElementById('gameOver').style.display = 'none';
            updateUI();
        }

        function calculateUnifiedEnemyFontSize() {
            const tempCtx = document.createElement('canvas').getContext('2d');
            tempCtx.imageSmoothingEnabled = false;
            const maxTextWidth = scale(ENEMY_BASE_WIDTH) * 0.9;
            const longestWord = ALL_WORDS.reduce((a, b) => tempCtx.measureText(a).width > tempCtx.measureText(b).width ? a : b, '');
            let testFontSize = scale(50);
            const minAllowedEnemyFontSize = 8;
            while (testFontSize >= minAllowedEnemyFontSize) {
                tempCtx.font = `bold ${testFontSize}px 'DotGothic16', 'Press Start 2P'`;
                if (tempCtx.measureText(longestWord).width <= maxTextWidth) break;
                testFontSize -= 1;
            }
            UNIFIED_ENEMY_FONT_SIZE = Math.max(testFontSize, minAllowedEnemyFontSize);
        }

        function createEnemies() {
            gameState.enemies = [];
            const enemyWidth = scale(ENEMY_BASE_WIDTH);
            const enemyHeight = scale(ENEMY_BASE_HEIGHT);
            const colSpacing = scale(ENEMY_COL_SPACING);
            const rowSpacing = scale(ENEMY_ROW_SPACING);
            const totalEnemyGridWidth = (ENEMY_COLS - 1) * colSpacing + enemyWidth;
            const firstEnemyX = (canvas.width - totalEnemyGridWidth) / 2;
            const startY = scale(ENEMY_START_Y_OFFSET);
            const uniquePlayerTargetPositions = new Set();

            for (let row = 0; row < ENEMY_ROWS; row++) {
                for (let col = 0; col < ENEMY_COLS; col++) {
                    const enemyText = ALL_WORDS[Math.floor(Math.random() * ALL_WORDS.length)];
                    const enemyX = firstEnemyX + col * colSpacing;
                    const enemyY = startY + row * rowSpacing;
                    const enemyCenterX = enemyX + enemyWidth / 2;

                    gameState.enemies.push({
                        x: enemyX, y: enemyY, width: enemyWidth, height: enemyHeight,
                        alive: true, text: enemyText, centerX: enemyCenterX
                    });
                    uniquePlayerTargetPositions.add(parseFloat(enemyCenterX.toFixed(2)));
                }
            }

            gameState.playerTargetPositions = Array.from(uniquePlayerTargetPositions).sort((a, b) => a - b);
            const playerHalfWidth = gameState.player.width / 2;
            gameState.playerTargetPositions = gameState.playerTargetPositions.filter(pos =>
                pos >= playerHalfWidth && pos <= canvas.width - playerHalfWidth
            );
        }

        function handleKeyDown(e) {
            if (gameState.isPaused || explanationOverlay.style.display === 'flex' || spreadsheetOverlay.style.display === 'flex' || gameState.gameOver) return;
            gameState.keys[e.key] = true;
        }

        function toggleDebug() {
            showDebugLines = !showDebugLines;
        }

        function movePlayer(direction) {
            if (gameState.isPaused || gameState.playerTargetPositions.length === 0) return;
            const newIndex = gameState.currentPlayerTargetIndex + direction * PLAYER_GRID_MOVE_AMOUNT;
            if (newIndex >= 0 && newIndex < gameState.playerTargetPositions.length) {
                gameState.currentPlayerTargetIndex = newIndex;
                gameState.player.x = gameState.playerTargetPositions[newIndex] - gameState.player.width / 2;
            }
            gameState.player.x = Math.max(0, Math.min(canvas.width - gameState.player.width, gameState.player.x));
        }

        function shoot(type) {
            if (gameState.isPaused || gameState.gameOver || performance.now() - gameState.lastShootTime < SHOOT_COOLDOWN) return;
            gameState.bullets.push({
                x: gameState.player.x + gameState.player.width / 2 - scale(BULLET_PLAYER_BASE_WIDTH) / 2,
                y: gameState.player.y,
                width: scale(BULLET_PLAYER_BASE_WIDTH),
                height: scale(BULLET_PLAYER_BASE_HEIGHT),
                speed: scale(BULLET_PLAYER_BASE_SPEED),
                type: type
            });
            gameState.lastShootTime = performance.now();
        }

        function updateBullets() {
            gameState.bullets = gameState.bullets.filter(b => (b.y -= b.speed) > 0);
            gameState.enemyBullets = gameState.enemyBullets.filter(b => (b.y += b.speed) < canvas.height);
        }

        function updateEnemies() {
            if (Math.random() < ENEMY_SHOOT_CHANCE_BASE * (gameState.level * ENEMY_SHOOT_CHANCE_LEVEL_FACTOR)) {
                const aliveEnemies = gameState.enemies.filter(e => e.alive && e.y < canvas.height - scale(100));
                if (aliveEnemies.length > 0) {
                    const enemy = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
                    gameState.enemyBullets.push({
                        x: enemy.x + enemy.width / 2 - scale(BULLET_ENEMY_BASE_WIDTH) / 2,
                        y: enemy.y + enemy.height,
                        width: scale(BULLET_ENEMY_BASE_WIDTH),
                        height: scale(BULLET_ENEMY_BASE_HEIGHT),
                        speed: scale(BULLET_ENEMY_BASE_SPEED)
                    });
                }
            }
            const currentTime = performance.now();
            const currentDropInterval = Math.max(MIN_DROP_INTERVAL, BASE_AUTO_DROP_INTERVAL - ((gameState.level - 1) * LEVEL_DROP_INTERVAL_REDUCTION));
            if (currentTime - gameState.lastEnemyAutoDropTime > currentDropInterval) {
                dropAllEnemies(scale(ENEMY_BASE_HEIGHT * ENEMY_AUTO_DROP_FACTOR));
                gameState.lastEnemyAutoDropTime = currentTime;
            }
        }

        function dropAllEnemies(dropAmount) {
            for (const enemy of gameState.enemies) {
                if (enemy.alive) {
                    enemy.y += dropAmount;
                    if (enemy.y + enemy.height >= gameState.player.y) {
                        setGameOver();
                        break;
                    }
                }
            }
        }

        function checkCollisions() {
            const dropAmountCollision = scale(ENEMY_DROP_AMOUNT_COLLISION);
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    if (enemy.alive && isColliding(bullet, enemy)) {
                        const isMatch = (bullet.type === 'hamachi' && HAMACHI_WORDS.includes(enemy.text)) ||
                                        (bullet.type === 'kanpachi' && KANPACHI_WORDS.includes(enemy.text));
                        if (isMatch) {
                            enemy.alive = false;
                            gameState.score += 10;
                            if (bullet.type === 'hamachi') {
                                playSound('audio-hamachi');
                            } else {
                                playSound('audio-kanpachi');
                            }
                        } else {
                            gameState.score = Math.max(0, gameState.score - 5);
                            playSound('audio-chigau');
                            dropAllEnemies(dropAmountCollision);
                        }
                        gameState.bullets.splice(i, 1);
                        break; 
                    }
                }
            }
            for (let i = gameState.enemyBullets.length - 1; i >= 0; i--) {
                const bullet = gameState.enemyBullets[i];
                if (isColliding(bullet, gameState.player)) {
                    gameState.enemyBullets.splice(i, 1);
                    gameState.lives--;
                    playSound('audio-vu');
                    dropAllEnemies(dropAmountCollision);
                    if (gameState.lives <= 0) setGameOver();
                }
            }
            for (const enemy of gameState.enemies) {
                if (enemy.alive && isColliding(enemy, gameState.player)) {
                    playSound('audio-vu');
                    setGameOver();
                    break;
                }
            }
        }

        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
        }

        function setGameOver() {
            gameState.gameOver = true;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = gameState.score;
            saveHighScore(gameState.score);
            submitScoreToGoogleForm(gameState.playerName, gameState.score);
            yourRankDisplay.textContent = "";
            exitButton.style.display = 'none';
        }

        function checkLevelUp() {
            if (gameState.enemies.length > 0 && !gameState.enemies.some(e => e.alive)) {
                if (gameState.isPaused) return;

                gameState.isPaused = true;
                playSound('audio-clear');

                setTimeout(() => {
                    gameState.level++;
                    createEnemies();
                    if (gameState.playerTargetPositions.length > 0) {
                        const middleIndex = Math.floor(gameState.playerTargetPositions.length / 2);
                        gameState.currentPlayerTargetIndex = middleIndex;
                        gameState.player.x = gameState.playerTargetPositions[middleIndex] - gameState.player.width / 2;
                    }
                    gameState.lastEnemyAutoDropTime = performance.now();
                    gameState.isPaused = false;
                }, 1000);
            }
        }

        function drawWater() {
            const waterSurfaceY = scale(ENEMY_START_Y_OFFSET) + scale(WATER_SURFACE_Y_OFFSET_FROM_ENEMY_TOP);
            const waveAmplitude = scale(WAVE_AMPLITUDE_BASE);
            const waveFrequency = WAVE_FREQUENCY_BASE;

            ctx.fillStyle = WATER_COLOR_BOTTOM;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.beginPath();
            ctx.moveTo(0, waterSurfaceY);
            for (let x = 0; x <= canvas.width; x += scale(4)) {
                ctx.lineTo(x, waterSurfaceY + Math.sin(x * waveFrequency + frameCount * 0.1) * waveAmplitude);
            }
            ctx.lineTo(canvas.width, 0);
            ctx.lineTo(0, 0);
            ctx.closePath();
            ctx.fillStyle = WATER_COLOR_TOP;
            ctx.fill();

            const drawWaveLine = (color, offset) => {
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = scale(2);
                ctx.moveTo(offset, waterSurfaceY + offset);
                for (let x = 0; x <= canvas.width; x += scale(4)) {
                    ctx.lineTo(x + offset, waterSurfaceY + Math.sin(x * waveFrequency + frameCount * 0.1) * waveAmplitude + offset);
                }
                ctx.stroke();
            };
            drawWaveLine(WATER_LINE_SHADOW_COLOR, scale(1));
            drawWaveLine(WATER_LINE_COLOR, 0);
        }

        function draw() {
            drawWater();

            if (gameState.player.x !== undefined) {
                ctx.fillStyle = PLAYER_SHADOW_COLOR;
                ctx.fillRect(gameState.player.x + scale(2), gameState.player.y + scale(2), gameState.player.width, gameState.player.height);
                ctx.fillStyle = PLAYER_COLOR;
                ctx.fillRect(gameState.player.x, gameState.player.y, gameState.player.width, gameState.player.height);
            }

            gameState.bullets.forEach(b => {
                const shadowColor = b.type === 'hamachi' ? '#003366' : '#660033';
                const mainColor = b.type === 'hamachi' ? PLAYER_BULLET_COLOR_HAMACHI : PLAYER_BULLET_COLOR_KANPACHI;
                ctx.fillStyle = shadowColor;
                ctx.fillRect(b.x + scale(1), b.y + scale(1), b.width, b.height);
                ctx.fillStyle = mainColor;
                ctx.fillRect(b.x, b.y, b.width, b.height);
            });
            gameState.enemyBullets.forEach(b => {
                ctx.fillStyle = ENEMY_BULLET_SHADOW_COLOR;
                ctx.fillRect(b.x + scale(1), b.y + scale(1), b.width, b.height);
                ctx.fillStyle = ENEMY_BULLET_COLOR;
                ctx.fillRect(b.x, b.y, b.width, b.height);
            });

            ctx.font = `bold ${UNIFIED_ENEMY_FONT_SIZE}px 'DotGothic16', 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (const enemy of gameState.enemies) {
                if (!enemy.alive) continue;
                ctx.fillStyle = enemyBlockStyles.shadowColor || '#003300';
                ctx.fillRect(enemy.x + scale(2), enemy.y + scale(2), enemy.width, enemy.height);
                ctx.fillStyle = enemyBlockStyles.mainColor || '#006600';
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);

                ctx.fillStyle = enemyBlockStyles.textShadowColor || '#003300';
                ctx.fillText(enemy.text, enemy.x + enemy.width / 2 + scale(2), enemy.y + enemy.height / 2 + scale(2));
                ctx.fillStyle = enemyBlockStyles.textColor || '#99ff99';
                ctx.fillText(enemy.text, enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
            }
        }

        // ===== 構文エラーを修正した関数 =====
        function drawLevelUpMessage() {
            const text = `LEVEL ${gameState.level + 1}`;
            ctx.save();

            const fontSize = scale(80);
            ctx.font = `bold ${fontSize}px 'DotGothic16', 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillText(text, canvas.width / 2 + scale(6), canvas.height / 2 + scale(6));
            
            // CSS変数を直接使わず、実際のカラーコードを指定する
            ctx.fillStyle = '#cc9900'; // var(--color-text-title-shadow)
            ctx.fillText(text, canvas.width / 2 + scale(3), canvas.height / 2 + scale(3));

            ctx.fillStyle = '#ffcc00'; // var(--color-text-title)
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            ctx.restore();
        }

        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('level').textContent = gameState.level;
        }

        function gameLoop() {
            if (!gameState.gameOver) {
                if (!gameState.isPaused) {
                    updateBullets();
                    updateEnemies();
                    checkCollisions();
                    checkLevelUp();
                }
            }

            draw();

            if (gameState.isPaused && !gameState.gameOver) {
                drawLevelUpMessage();
            }

            updateUI();
            frameCount++;
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function saveHighScore(score) {
            if (score > gameState.personalHighScore) {
                gameState.personalHighScore = score;
                localStorage.setItem('hamachiKanpachiHighScore', score);
                displayHighScore();
            }
        }

        function loadHighScore() {
            const storedScore = localStorage.getItem('hamachiKanpachiHighScore');
            gameState.personalHighScore = storedScore ? parseInt(storedScore, 10) : 0;
            displayHighScore();
        }

        function displayHighScore() {
            if (personalHighScoreDisplay) {
                personalHighScoreDisplay.textContent = gameState.personalHighScore > 0
                    ? `あなたの最高得点: ${gameState.personalHighScore} 点`
                    : 'あなたの最高得点: まだありません';
            }
        }

        async function submitScoreToGoogleForm(playerName, score) {
            const formData = new FormData();
            formData.append(FORM_PLAYER_NAME_ENTRY_ID, playerName);
            formData.append(FORM_SCORE_ENTRY_ID, score);
            try {
                await fetch(GOOGLE_FORM_URL, { method: 'POST', mode: 'no-cors', body: formData });
            } catch (error) {
                console.error('Error submitting score to Google Form:', error);
            }
        }

        function refreshRankingSource() {
            rankingIframe.src = BASE_RANKING_URL + '&timestamp=' + new Date().getTime();
        }

        function showStartScreen() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameState.gameOver = true;
            startButtonContainer.style.display = 'flex';
            gameContainer.style.display = 'none';
            ui.style.display = 'none';
            document.getElementById('mobileControls').style.display = 'none';
            exitButton.style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            loadHighScore();
            if (mainTitle) mainTitle.style.animationPlayState = 'running';
        }

        window.addEventListener('resize', () => {
            if (gameContainer.style.display !== 'none' || startButtonContainer.style.display !== 'none') {
                init();
            } else {
                resizeGameContainer();
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            resizeGameContainer();
            showStartScreen();
            explanationOverlay.style.display = 'none';
            spreadsheetOverlay.style.display = 'none';
            playerNameErrorMessage.style.visibility = 'hidden';
            setupResizeObservers();
            cacheEnemyStyles();
        });

        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', (e) => { gameState.keys[e.key] = false; });

        const addTouchListener = (element, action) => {
            element.addEventListener('mousedown', (e) => {
                if (gameState.gameOver) return;
                e.preventDefault();
                action();
            }, { passive: false });
            element.addEventListener('touchstart', (e) => {
                if (gameState.gameOver) return;
                e.preventDefault();
                action();
            }, { passive: false });
        };
        addTouchListener(document.getElementById('leftButton'), () => movePlayer(-1));
        addTouchListener(document.getElementById('rightButton'), () => movePlayer(1));
        addTouchListener(document.getElementById('shootHamachiButton'), () => shoot('hamachi'));
        addTouchListener(document.getElementById('shootKanpachiButton'), () => shoot('kanpachi'));

        startButton.addEventListener('click', () => {
            const playerName = playerNameInput.value.trim();
            if (playerName === "") {
                playerNameErrorMessage.textContent = "名前を入力してください";
                playerNameErrorMessage.style.visibility = 'visible';
                return;
            }
            playerNameErrorMessage.style.visibility = 'hidden';
            gameState.playerName = playerName.substring(0, 10);

            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn("Web Audio API not supported.", e);
                }
            }
            
            document.querySelectorAll('audio').forEach(audio => {
                const originalVolume = audio.volume;
                audio.volume = 0;

                const promise = audio.play();
                if (promise !== undefined) {
                    promise.then(_ => {
                        audio.pause();
                        audio.currentTime = 0;
                        audio.volume = originalVolume;
                    }).catch(error => {
                        audio.volume = originalVolume;
                    });
                } else {
                    audio.volume = originalVolume;
                }
            });

            setTimeout(() => {
                playSound('audio-start');
            }, 500);


            startButtonContainer.style.display = 'none';
            ui.style.display = 'flex';
            gameContainer.style.display = 'block';
            document.getElementById('mobileControls').style.display = 'flex';
            exitButton.style.display = 'block';

            init();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
            if (mainTitle) mainTitle.style.animationPlayState = 'paused';
        });

        explainButton.addEventListener('click', () => {
            startButtonContainer.style.display = 'none';
            explanationOverlay.style.display = 'flex';
            if (mainTitle) mainTitle.style.animationPlayState = 'paused';
        });

        closeExplanationButton.addEventListener('click', () => {
            explanationOverlay.style.display = 'none';
            showStartScreen();
        });

        rankingButton.addEventListener('click', () => {
            spreadsheetOverlay.style.display = 'flex';
        });

        closeSpreadsheetButton.addEventListener('click', () => {
            spreadsheetOverlay.style.display = 'none';
        });

        restartButton.addEventListener('click', () => {
            playSound('audio-retry');
            refreshRankingSource();
            showStartScreen();
        });

        exitButton.addEventListener('click', showStartScreen);

    </script>
</body>
</html>
